格式化字符串函数可以接受可变数量的参数，并将**第一个参数作为格式化字符串，根据其来解析之后的参数**。

![](https://cdn.nlark.com/yuque/0/2025/png/49997581/1753813146976-6971ef40-c856-4f82-b0ce-680278ed4f19.png)

```plain
a=1;
buf="orange";
printf("hello %d %s",a,buf);
printf(buf);
```



| 占位符  | 含义 |
| --- | --- |
| %d  | 以十进制形式输出整数 |
| %u | 以十进制形式输出无符号整数 |
| **%x ** | **以十六进制形式输出整数（小写字母）** |
| %X | 以十六进制形式输出整数（大写字母） |
| %o |  以十进制形式输出整数 |
| %f | 以浮点数形式输出实数 |
| %e  | 以指数形式输出实数 |
| %g  | 自动选择%f或者%e输出实数 |
| **%c ** | ** 输出单个字符** |
| **%s** | **输出字符串** |
| **%p** | **用地址的格式输出参数的值** |
| **%n** | **将已经输出的字符数写入参数** |


格式化字符串漏洞利用中，常用%p来泄露地址，使用%n来实现向指定地址写入数据（4字节），通常还会使用%hn（2字节）,%hhn（1字节）,%lln（8字节）进行写入。

%n$(),直接指定参数相对于格式化字符串的偏移

利用它，就可以获取到对应的第 n+1 个参数的数值。为什么这里是对应第 n+1 个参数呢？这是因为 n 指的是该格式化字符串对应的第 n 个输出参数，相对于printf函数来说，是第 n+1 个参数。

---

x86(32位）：函数参数通过**栈**传参

x86-64(64位)：函数参数先通过寄存器`rdi,rsi,rdx,rcx,r8,r9`来传参，再通过**栈**来传参

## 栈上的格式化字符串漏洞利用
### 任意地址泄露：
1. 利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。
2. 利用 %s 来获取变量所对应地址的内容，只不过有零截断。
3. 利用 %(order)$p 来获取指定参数的值，利用 %(order)$s 来获取指定参数对应地址的内容。

---

#### 保护机制
**canary:**

Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。

我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖 rbp、rip等，从而达到劫持控制流的目的。栈溢出保护是一种缓冲区溢出攻击缓解手段。当启用栈保护后，函数开始执行的时候会先往栈底插入 canary信息，当函数真正返回的时候会验证 canary是否合法 (栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行 (栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 canary信息给覆盖掉，导致栈保护检查失败,避免漏洞利用成功。

开启 Canary 保护的 stack 结构大概如下：

```plain
High  Address|                 |
                +-----------------+
                | args            |
                +-----------------+
                | return address  |
                +-----------------+
        rbp =>  | old rbp         |
                +-----------------+
      rbp-8 =>  | canary value    |
                +-----------------+
                | local variables |
    Low Address |                 |
```

如果 Canary 已经被非法修改，此时程序流程会走到 `__stack_chk_fail`。`__stack_chk_fail` 也是位于 glibc 中的函数

Canary 设计为以字节 `\x00` 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。 这种利用方式需要存在合适的输出函数，并且可能需要第一溢出泄露 Canary，之后再次溢出控制执行流程。

**pie:**

`**PIE**`是对二进制程序做的地址随机化PIE（Position Independent Executables),主要的功能是随机化了ELF装载的基地址，使用分页内存偏移定位到每一行指令，因为程序运行起来的时候开启了pie和aslr，无法获取程序的准确地址，但是虽然前面的地址是不知道的，但是一个内存分页的大小为`**0x1000**`，这基本上确定了，偏移地址只能在`**0~999**`之间，也就是说，后三位数字为真实的地址

pie只会影响程序加载的基地址，如果程序中某个函数，泄露了程序在内存中的地址，我们可以将`**泄露的地址 - 泄露地址偏移**`得到基地址，从而可以使用`**基地址 + 偏移**`地址定位到程序中的任意位置。

可以利用**格式化字符串漏洞**实现libc基地址，canary和pie基地址的泄露

### 任意地址写：
如果我们输入%数字c%数字$n,就可以实现任意地址写

1. 修改内存值
2. 修改函数got表

---

**手写:**

fmtstr =b"%" + str(num).encode() + b"c"+b"%" + str(index).encode()+ b"$hhn"

```plain
payload=b"%123c%11$hhn"+b"%321c%12$hn"
'''
  %hhn 1字节     
  %hn  2字节
  %n   4字节
  通常情况下，按顺序优先使用这三种占位符，需根据具体情况修改
'''
```

**自动构造(fmtstr_payload):**

```plain
fmtstr_payload(offset, writes, numbwritten=0, write_size='byte')
```

| 参数 | 含义 |
| --- | --- |
| offset | 当前可控制的第一个 %x$ 参数索引 |
| writes |  字典 {addr: value, ...}，指定目标地址与要写入的数据 |
| numbwritten  | printf 已输出的字节数，确保 padding 精度 |
| write_size | 'byte', 'short', 'int'，分别对应 %hhn, %hn, %n 写入粒度  |


## 非栈上的格式化字符串漏洞利用
为什么叫做非栈上的格式化字符串，是因为我们输入的buffer，不存在栈上，回想一下我们的栈上的格式化字符串漏洞利用，我们将我们要改写的地址写到栈上，这样格式化字符串就可以直接找到这个地址，从而进行修改，但是我们的输入buffer不存在于栈上，这时候我们输入的地址，格式化字符串就无法找到这个地址了，我们就很难做到任意地址写了，那么非栈上的格式化字符串漏洞我们该如何利用呢？

其实我们可以通过漏洞，修改函数返回地址，然后精心构造ROP链，就可以完成攻击，这里不再介绍，我们这里来介绍复写函数地址的方法

我们还是以将printf_got表地址改写为system函数地址为例：

我们在程序的栈上很容易找到这样的一段：

![](https://cdn.nlark.com/yuque/0/2025/png/49997581/1753813147117-2915f36f-94ce-4ad6-8d79-c926974ba5f6.png)

这样我们就可以使用诸葛连弩了，我们使用格式化字符串漏洞，将offset_2改为offset_3，这样的话我们就可以实现一段四个链的地址了，像这样：

![](https://cdn.nlark.com/yuque/0/2025/png/49997581/1753813147073-b10b3b15-06e5-43ac-a995-c1c46efc6e81.png)

我们以64位应用程序为例，我们就可以使用格式化字符串漏洞，将offset_3地址处修改为printf_got表地址，也就是把offset_4改为printf_got表地址，然后我们使用offset_1处，将printf_got表内容修改为system函数的地址。

