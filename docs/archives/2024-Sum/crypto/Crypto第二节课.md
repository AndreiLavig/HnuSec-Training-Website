# 课前准备：掌握python的基本用法
# 第一部分：初等数论
## 1.整除
定义：若[整数](https://baike.baidu.com/item/%E6%95%B4%E6%95%B0/1293937?fromModule=lemma_inlink)b除以非零整数a，商为整数，且[余数](https://baike.baidu.com/item/%E4%BD%99%E6%95%B0/6180737?fromModule=lemma_inlink)为零，b为被除数，a为[除数](https://baike.baidu.com/item/%E9%99%A4%E6%95%B0/485249?fromModule=lemma_inlink)，即a|b（“|”是整除符号），读作“a整除b”或“b能被a整除”。a叫做b的约数（或因数），b叫做a的倍数。

## 2.欧几里得算法
欧几里得算法是求两个数最大公因数最有效的办法，由直到余数为0的一系列带余除法组成，又名辗转相除法。
•e.g. gcd(36,132)132=3*36+24 36=1*24+12 24=2*12+0
•则gcd(36,132)=12
•e.g. gcd(1160718174,316258250)
•1160718174=3*316258250+211943424
•316258250=1*211943424+104314826
•211943424=2*104314826+3313772
•104314826=31*3313772+1587894
•3313772=2*1587894+137984
•1587894=11*137984+70070
•137984=1*70070+67914
•70070=1*67914+2156
•67914=31*2156+1078
•2156=2*1078+0
•则gcd(1160718174,316258250)=1078

## 3.同余关系：
同余符号：
两个整数a、b，若它们除以整数m所得的[余数](https://baike.baidu.com/item/%E4%BD%99%E6%95%B0/6180737?fromModule=lemma_inlink)相等，则称a与b对于模m同余或a同余于b模m。
记作：a≡b (mod m)，
读作：a同余于b模m，或读作a与b对模m同余，例如26≡2(mod 12)。
定义
设m是大于1的正整数，a、b是整数，如果m|(a-b)，则称a与b关于模m同余，记作a≡b(mod m)，读作a与b对模m同余。
显然,有如下事实
（1）若a≡0(mod m)，则m|a；
（2）a≡b(mod m)等价于a与b分别用m去除，余数相同。

## 4.同余的相关性质：
性质1：a≡a（mod m），（反身性）性质2：若a≡b（mod m），那么b≡a（mod m）（对称性）
性质3：若a≡b（mod m），b≡c（mod m）=>a≡c（mod m）（传递性）这三个性质比较简单，不做证明
性质4：若a≡b（mod m），c≡d（mod m），那么a±c≡b±d（mod m）（可加减性）
证明：设a=A+Ka*m,b=A+Kb*m,c=C+Kc*m,d=C+Kd*m则(a±c)%m=(A±C) (b±d)%m=(A±C)即a±c≡b±d（mod m）
性质5：若a≡b（mod m），c≡d（mod m），那么ac≡bd（mod m）（可乘性）
性质6：若a≡b（mod m），那么an≡bn（mod m）（其中n为自然数）证明：由性质1和性质5得。
性质7：若ac≡bc（mod m），（c，m）=1，那么a≡b（mod m）**（）的意思为最大公因数**
性质8：若a≡b（mod m），那么a^t≡b^t（mod m）证明：由性质5得。
性质9：若 a≡b(mod m1) a≡b(mod m2)…. a≡b(mod mk) 则 a≡b(mod [m1,m2……mk]

## 5.乘法逆元：
•在加法中，我们有𝑎+(−𝑎)=0，我们称其互为相反数。
在乘法中，我们有𝑎⋅(1/𝑎)=1，我们称其互为倒数。
在矩阵中，我们有𝑀⋅![](https://cdn.nlark.com/yuque/__latex/adf82f34289edea2b67aff078cc635f5.svg#card=math&code=M%5E%7B-1%7D&id=XFhoD)=E，我们称其为逆矩阵

但是其实我们可以用一个统一的称呼：**逆元**，即某种运算下的逆元素，我们会发现，元素和其逆元素进行运算之后总是一个定值，实际上在代数中，他们构成了一个群（不用深究），而我们进行要了解则是在模意义下的乘法逆元。
在模 𝑝意义下，指的是后续的所有运算都是在模 𝑝的条件下满足，例如 3⋅4不等于1
但3⋅4≡1(mod11)
所以参考上面乘法中的逆元运算规则，在模意义下则有
𝑎⋅![](https://cdn.nlark.com/yuque/__latex/b179233a3d1fa2767ffe52dd2ac41af0.svg#card=math&code=a%5E%7B-1%7D&id=dThUu)≡1(mod𝑝)
我们称 𝑎和 ![](https://cdn.nlark.com/yuque/__latex/b179233a3d1fa2767ffe52dd2ac41af0.svg#card=math&code=a%5E%7B-1%7D&id=gxNkW)互为在模 𝑝意义下的乘法逆元。例如上述中的 3 与 4 互为在模 11 下的乘法逆元

## 6.欧拉定理&费马小定理
费马小定理：**若存在整数 a , p 且gcd(a,p)=1,即二者互为质数，则有a^（p-1）≡ 1(mod p)。**
e.g. 计算2^35(mod 7)
由于2^6≡1(mod 7)，记35=6*5+5，有2^35=(2^6)^5*2^5≡32≡4(mod 7)
欧拉函数：
在1与m之间且与m互素的整数个数称为Φ(m)，即欧拉函数，其性质如下：
①若p为素数，Φ(p)=p-1
②Φ(mn)=Φ(m)*Φ(n)
简单来说就是给定一个正整数 n ，欧拉函数就是求在 [ 1 , n )  区间上，与 n互质的整数的个数。
举例来说，设m = 8 ，则与8互质的正整数集合A={1, 3, 5, 7}
此集合共有4个元素,所以φ(8)=4 。
欧拉定理：如果gcd(a,m)=1，则a^Φ(m)≡1(mod m)

## 7.中国剩余定理：
![](https://cdn.nlark.com/yuque/__latex/d069049f2b8271de8fe295e77fab1197.svg#card=math&code=%E8%AE%BE%E6%95%B4%E6%95%B0m_%7B1%7D%2Cm_%7B2%7D%2C...m_%7Bk%7D%2C%E4%B8%A4%E4%B8%A4%E4%BA%92%E7%B4%A0%EF%BC%8C%E5%88%99%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%BB%84%EF%BC%9A%0A&id=FJzF8)
![](https://cdn.nlark.com/yuque/__latex/8322beaf47c8361d8d8064df1f7545ed.svg#card=math&code=%5Cqquad%20%5Cbegin%7Bcases%7Dx%5Cequiv%20a%7B_1%7D%28mod%5Cquad%20m_%7B_1%7D%29%5C%5Cx%5Cequiv%20a_%7B_2%7D%28mod%5Cquad%20m_%7B_2%7D%29%5C%5C......%5C%5Cx%5Cequiv%20a_%7B_k%7D%28mod%20%5Cquad%20m_%7B_k%7D%29%5Cend%7Bcases%7D&id=NIrr5)
有整数解，![](https://cdn.nlark.com/yuque/__latex/6b96812b1576faea2401e0ff89c122c0.svg#card=math&code=%E5%B9%B6%E4%B8%94%E5%9C%A8%E6%A8%A1M%3Dm_%7B_1%7D%2Am_%7B_2%7D%2A...%2Am_%7B_k%7D%E4%B8%8B%E7%9A%84%E8%A7%A3%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%E3%80%82%0A&id=MM9At)

# 第二部分.rsa入门
## rsa介绍
•RSA 加密算法，一种非对称加密算法，在各种场景与环境下都有它的身影，那么它和其它加密算法又有什么不同呢，以及什么是非对称加密算法？

•**非对称加密**：传统的加密算法基于同一密钥进行加密和解密，此时我们会发现我们攻击的重点将落在通信双方的密钥到底是什么，因为即使你的加密算法天衣无缝，但是你的密钥泄露了，我便可以直接通过解密算法得到密钥。
•在一个不安全的通信环境中，你的信息需要经过很多节点（中间人）才能传输至目标，此时我们考虑两个问题：
•如何保证发送的信息没有被窃取？
•如何保证是可信的发送人（即别人不能伪造你的身份发送信息）？
•其实这便是信息安全等级保护中的**CIA**三要素的机密性（Confidentiality）和完整性（Integrity）要求。
•显然，依靠传统的对称密码我们没办法做到这两点，因为传统对称密码需要事先约定使用某个特定的密码进行通信。此时我们考虑这样一个加密算法，它拥有两组密钥
•_公开密钥Pk（Public key）_：又称公钥，可以公开给所有人进行存储。
•_私有密钥Sk（Secret key）_：又称私钥，只能是发送者自己保存。
•如果我们规定**加密**时使用**公钥**，**解密**时使用**私钥**，那么似乎我们的第一个问题中的放窃取便有了解决方案
•我Bob要给Alice发送信息，此时我只需要获取Bob的公开密钥（因为这会公开给所有人），然后用这个**公钥**将我们的信息进行加密，再发送给Alice即可，Alice收到信息后只需要用自己的**私钥**解密即可。
•具体怎么实现可以先不管

•RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。
•整个密码学的基石都是基于一些数学难题，以RSA算法为例，其基于大整数分解难题（IFP），目前来说我们并没有什么有效的办法对一个极大整数做因式分解，再多的优化在极大整数面前都与爆破无异，这保障了RSA的安全性。

## 接下来我们将学习RSA是如何工作的
•**生成公私钥**
•选取两个不同的大**素数** 𝑝 和 𝑞 ，计算 𝑁=𝑝⋅𝑞。
•求**欧拉函数**值： 𝜑(𝑁)=𝜑(𝑝)𝜑(𝑞)=(𝑝−1)(𝑞−1）
•选择一个小于 𝜑(𝑁) 的整数 𝑒 ，并且满足 𝑒和 𝜑(𝑁) **互质**，求得 𝑒 在模 𝜑(𝑁) 意义下的**乘法逆元** 𝑑，有 𝑒𝑑≡1(mod 𝜑(𝑁))。
•销毁 𝑝 和 𝑞 。
•此时有 (𝑁,𝑒) 为公钥， (𝑁,𝑑)为私钥。

**加密**
RSA算法本质上都是基于数学运算，在加密时我们需要先将消息转化为一个数字 𝑚（例如消息ASCII码的二进制排列转为数字），然后有
**𝑐≡𝑚^𝑒(mod𝑁)**
此时得到的 𝑐 便是我们的密文。
**解密**
加密时我们只用到了公钥 (𝑁,𝑒)，同理解密时我们也只需用到私钥 (𝑁,𝑑)。有
**𝑚≡𝑐^𝑑(mod𝑁)**
此时得到的 𝑚便是我们的明文消息。

以下是证明过程：
情况1：m，n互素，由欧拉定理
![](https://cdn.nlark.com/yuque/__latex/b87db940d5321a96002e065757fbef0c.svg#card=math&code=c%5Ed%5Cequiv%20m%5E%7Bed%7D%5Cequiv%20m%5E%7Bk%2A%5Cphi%28n%29%2B1%7D%5Cequiv%20m%2Am%5E%7B%28%5Cphi%28n%29%29k%7D%5Cequiv%20m%5Cquad%20mod%20%5Cquad%20n&id=eqlAX)

情况2：m,n不互素
因为n=pq，假设m=tp，此时gcd(m,q)=1,否则m也是q的倍数，这样与m<n不符
由gcd(m,q)=1得
![](https://cdn.nlark.com/yuque/__latex/87a875792ddd4a843e822285bafcb06b.svg#card=math&code=%5Cqquad%20m%5E%7B%5Cphi%28q%29%7D%5Cequiv%201%5Cquad%20mod%5Cquad%20q%5Cnewline%0A%E6%89%80%E4%BB%A5%5Cqquad%20m%5E%7Bk%5Cphi%28p%29%5Cphi%28q%29%7D%20%5Cequiv1%5Cquad%20mod%5Cquad%20q%5Cnewline%0A%E5%8D%B3m%5E%7Bk%5Cphi%28n%29%7D%5Cequiv1%5Cquad%20mod%20%5Cquad%20q%E4%B9%9F%E5%B0%B1%E6%98%AFm%5E%7Bk%5Cphi%28n%29%7D%3Dkq%2B1%5Cnewline%0A%E4%B8%A4%E8%BE%B9%E5%90%8C%E6%97%B6%E4%B9%98%E4%B8%8Atp%EF%BC%8C%E5%BE%97m%5E%7Bk%5Cphi%28n%29%2B1%7D%3Dktpq%2Bm%3Dm%2Btkn%0A%5Cnewline%0A%E4%B9%9F%E5%B0%B1%E6%98%AFm%5E%7Bk%5Cphi%28n%29%2B1%7D%5Cequiv%20m%5Cquad%20mod%5Cquad%20n&id=OJAEv)

## rsa的典型例题
（一）
```
# from Crypto.Util.number import *

# flag = b'HnuSec{******}'

# p = getPrime(512)
# q = getPrime(512)
# n = p*q
# e = 65537
# phi = (p-1)*(q-1)

# m = bytes_to_long(flag)

# c = pow(m, e, n)

# print(f'p = {p}')
# print(f'q = {q}')
# print(f'e = {e}')
# print(f'c = {c}')

# '''
# p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951
# q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223
# e = 65537
# c = 16985928216066289607745655608472387841936273552452590075925415076465402241952445280629165681705095026645537863322715883371473926303620796321880246825754009888128254408835295906935265966545083338871054243768897499258970782403624741246921791153035995931189396857782268369332758021122743374765753179395584635103 
# '''





#exp：
from Crypto.Util.number import *
p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951
q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223
e = 65537
c = 16985928216066289607745655608472387841936273552452590075925415076465402241952445280629165681705095026645537863322715883371473926303620796321880246825754009888128254408835295906935265966545083338871054243768897499258970782403624741246921791153035995931189396857782268369332758021122743374765753179395584635103 

n=p*q
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)

print(long_to_bytes(m))
```
（二）
```
# from Crypto.Util.number import *

# flag = b'HnuSec{******}'

# p = getPrime(256)
# q = getPrime(256)
# n = p*q
# e = 65537
# phi = (p-1)*(q-1)

# m = bytes_to_long(flag)

# c = pow(m, e, n)

# print(f'n = {n}')
# print(f'e = {e}')
# print(f'c = {c}')

# '''
# n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881
# e = 65537
# c = 6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557
# '''


#exp：
from Crypto.Util.number import *
n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881
p = 70538125404512947763739093348083497980212021962975762144416432920656660487657
q = 104660876276442216612517835199819767034152013287345576481899196023866133215633
e = 65537
c = 6023918510559452489843355981344997081709643242016342576909710349188334663781373017167992053349226441070139392739476385352597362586543272965971077855905877 

n=p*q
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)

print(long_to_bytes(m))
```
（三）
```
# from Crypto.Util.number import *
# import gmpy2
# flag = b'Hnusec{******}'

# p = getPrime(512)
# q = gmpy2.next_prime(p)
# n = p*q
# e = 65537
# phi = (p-1)*(q-1)

# m = bytes_to_long(flag)

# c = pow(m, e, n)

# print(f'n = {n}')
# print(f'e = {e}')
# print(f'c = {c}')

# '''
# n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057
# e = 65537
# c = 98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730
# '''

#exp：
from Crypto.Util.number import *
from gmpy2 import *
p = getPrime(512)
q = gmpy2.next_prime(p)

n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057
e = 65537
c =46554995881534304163786911142572601366231266520429598003898822520945338285521641588246209180726042638679069273782104291578458664790967529994258540061934930305752343396677677004478592183690853094253593628826737255619938298419595076925140764290764269144692740652415108679368511749233623919822543128281102777990  

sn = isqrt(n)
q = next_prime(sn)
p = n // q

phi = (p-1)*(q-1)
d = invert(e, phi)

m = pow(c, d, n)
print(long_to_bytes(m))
```


# 课后作业：
1.自行学习其他数论知识
2.巩固并更深一步了解rsa相关内容
3.完成[crypto讲课作业提交处 - Ely::CTF (miaoaixuan.cn)](http://ctf.miaoaixuan.cn/games/4)发放的题目并按时提交wp

